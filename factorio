#!/bin/bash

### BEGIN INIT INFO
# Provides: Factorio
# Required-Start: $local_fs $network $remote_fs
# Required-Stop: $local_fs $network $remote_fs
# Default-Start:  2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: start and stop Factorio server
# Description: A init script for Factorio, try the help command
### END INIT INFO

debug(){
  if [ ${DEBUG} -gt 0 ]; then
    echo "DEBUG: $@" >&2
  fi
}

# Load config file
if [ -L $0 ]; then
  source `readlink -e $0 | sed "s:[^/]*$:config:"`
else
  source `echo $0 | sed "s:[^/]*$:config:"`
fi

if [ -z "${SERVICE_NAME}" ]; then
  echo "Couldn't load config file, please edit config.example and rename it to config"
  exit 1
fi

# Check/load defaults for backwards compatible config options
if [ -z "${PACKAGE_DIR_NAME}" ]; then
  PACKAGE_DIR_NAME=factorio
fi
if [ -z "${USERGROUP}" ]; then
  USERGROUP=${USERNAME}
fi
if [ -z "${HEADLESS}" ]; then
  # This is a server init script, assume headless default
  HEADLESS=1
fi

if ! [ $1 == "install" ]; then
  if [ -z ${FCONF} ]; then
    echo "Missing FCONF, ensure it's defined in your config and try again"
    exit 1
  fi
  
  if ! [ -e "${SERVER_SETTINGS}" ]; then
    echo "Could not find factorio server settings file: ${SERVER_SETTINGS}"
    echo "Update your config and point SERVER_SETTINGS to a modified version of data/server-settings.example.json"
    exit 1
  fi

  if ! [ -e ${FCONF} ]; then
    echo "Could not find factorio config file: ${FCONF}"
    echo "If this is the first time you run this script; You might need to generate the config.ini"
    echo "(also make sure the save exist or the command will fail)"
    echo "by running: sudo -u $USERNAME ${BINARY} --start-server ${SAVE_NAME}"
    exit 1
  fi
  if [ -z "${WRITE_DIR}" ]; then
    # figure out the write-data path (where factorio looks for saves and mods)
    # Note - this is a hefty little operation, possible cause of head ache down the road
    # as it relies on the factorio write dir to live ../../ up from the binary if __PATH__executable__
    # is used in the config file.. for now, that's the default so cross your fingers it will not change ;)
    WRITE_DIR=$(dirname "$(echo `grep "^write-data=" "$FCONF"` |cut -d'=' -f2 |sed -e 's#__PATH__executable__#'$(dirname "$BINARY")/..'#g')")
  fi
  debug "write path: $WRITE_DIR"

  PIDFILE="${WRITE_DIR}/server.pid"

fi

usage(){
  echo "Usage: $0 COMMAND"
  echo
  echo "Available commands:"
  echo -e "   start \t\t Starts the server"
  echo -e "   stop \t\t Stops the server"
  echo -e "   restart \t\t Restarts the server"
  echo -e "   status \t\t Displays server status"
  echo -e "   new-game \t\t Stops the server and creates a new game"
  echo -e "   save-game name \t Stops the server and saves game to specified save"
  echo -e "   load-save name \t Stops the server and loads the specified save"
  echo -e "   install tarball \t Installs the server with specified tarball"
  echo -e "   update [--dry-run] \t Updates the server"
}



ME=`whoami`
as_user() {
  if [ $ME == $USERNAME ]; then
    bash -c "$1"
  else
    su $USERNAME -s /bin/bash -c "$1"
  fi
}

is_running() {
  if [ -e ${PIDFILE} ]; then
    if kill -0 $(cat ${PIDFILE}) 2> /dev/null; then
      debug "${SERVICE_NAME} is running with pid $(cat ${PIDFILE})"
      return 0
    else
      debug "Found ${PIDFILE}, but the server is not running. It's possible that your server has crashed"
      debug "Check the log for details"
      rm ${PIDFILE} 2> /dev/null
      return 2
    fi
  fi
  return 1
}

start_service() {
  if [ ! -f "$BINARY" ]; then
    echo "Failed to start: Can't find the specified binary $BINARY. Please check your config!"
    return 1
  fi

  if ! check_permissions; then
    echo "Error! Incorrect permissions, unable to write to dir \"$WRITE_DIR\""
    return 1
  fi

  ${INVOCATION} > /dev/null 2>&1 &
  PID=$!

  ps -p ${PID} > /dev/null 2>&1
  if [ "$?" -ne "0" ]; then
    echo "Unable to start ${SERVICE_NAME}"
    return 1
  else
    echo ${PID} > ${PIDFILE}
    echo "Started ${SERVICE_NAME}, please see log for details"
  fi
}

stop_service() {
  if [ -e ${PIDFILE} ]; then
    echo -n "Stopping ${SERVICE_NAME}: "
    if kill -TERM $(cat ${PIDFILE}) 2> /dev/null; then
      sec=1
      while [ "$sec" -le 15 ]; do
        if [ -e ${PIDFILE} ]; then
          if kill -0 $(cat ${PIDFILE}) 2> /dev/null; then
            echo -n ". "
            sleep 1
          else
            break
          fi
        else
          break
        fi
        sec=$(($sec+1)) 
      done
    fi

    if [ -e ${PIDFILE} ]; then
      if kill -0 $(cat ${PIDFILE}) 2> /dev/null; then
        echo "Unable to shut down nicely, killing the process!"
        kill -KILL $(cat ${PIDFILE}) 2> /dev/null
      fi
    else
      echo "done"
    fi

    rm ${PIDFILE} 2> /dev/null
    return 0 # we've either shut down gracefully or killed the process
  else
    echo "${SERVICE_NAME} is not running (${PIDFILE} does not exist)"
    return 1
  fi
}

check_permissions() {
  if ! as_user "test -w '$WRITE_DIR'" ; then
    debug "Check Permissions. Cannot write to $WRITE_DIR"
    return 1
  fi
}

test_deps(){
  return 0 # TODO: Implement ldd check on $BINARY
}

install(){
  # Factorio comes packaged in a directory named "factorio"
  # Unless overriden in the config we will presume this is also the
  # name used in FACTORIO_PATH
  expected_path="`dirname ${FACTORIO_PATH}`/${PACKAGE_DIR_NAME}"
  if ! [ "${FACTORIO_PATH}" == "${expected_path}" ]; then
    echo "Aborting install! FACTORIO_PATH does not match expected path: ${expected_path}"
    echo "See config option PACKAGE_DIR_NAME for more details"
    exit 1
  fi

  # Prevent accitential overwrites
  if [ -e "${expected_path}" ]; then
    echo "Aborting install, ${FACTORIO_PATH} already exists"
    exit 1
  fi

  tarball=$1
  if ! [ -f "${tarball}" ]; then
    echo "Install package does not exist! ${tarball}"
    exit 1
  fi

  target="`dirname ${FACTORIO_PATH}`"
  if ! test -w "${target}"; then
    echo "Failed to write, aborting install!"
    echo "Install needs to be run as a user with write permissions to ${target}"
    exit 1
  fi

  echo "Installing ${tarball} ..."
  if ! tar -xzvf "${tarball}" --directory "${target}"; then
    echo "Install failed!"
    exit 1
  fi

  echo "Applying file ownership ..."
  if ! chown -R ${USERNAME}:${USERGROUP} ${FACTORIO_PATH}; then
    echo "Failed to apply ownership ${USERNAME}:${USERGROUP} for ${FACTORIO_PATH}"
    exit 1
  fi

  if test_deps; then
    if ! as_user "$BINARY --create ${SAVE_NAME}"; then
      echo "Installation complete..."
      echo
      echo "but failed to create initial save game."
      echo "Ensure you use: load-save [save-name] before starting the server for the first time."
    else
      echo "Install successfull!"
    fi
  else
    echo "Installation complete..."
    echo
    echo "but $BINARY is missing required dependencies."
    echo "Install the missing deps and ensure you use: load-save [save-name] before starting the server for the first time."
  fi
}

get_bin_version(){
  echo `as_user "$BINARY --version |egrep '^Version: [0-9\.]+' |egrep -o '[0-9\.]+' |head -n 1"`
}

get_bin_arch(){
  echo `as_user "$BINARY --version |egrep '^Binary version: ' |egrep -o '[0-9]{2}'"`
}

update(){
  if ! [ -e "${UPDATE_SCRIPT}" ]; then
    echo "Failed to find update script, blatantly refusing to continue!"
    echo "Try cloning into git@github.com:narc0tiq/factorio-updater.git and set the UPDATE_SCRIPT config before you try again."
    exit 1
  fi

  # Assume the user wants a dry run? (our only argument to this function)
  if ! [ -z "$1" ]; then
    echo "Running updater in --dry-run mode, no patches will be applied"
    dryrun=1
  else
    dryrun=0
  fi  

  if [ ${HEADLESS} -gt 0 ]; then
    package="core-linux_headless`get_bin_arch`"
  else
    package="core-linux`get_bin_arch`"
  fi
  
  version=`get_bin_version`
  if [ -z "${UPDATE_TMPDIR}" ]; then
    UPDATE_TMPDIR=/tmp
  fi
  
  tmpdir="${UPDATE_TMPDIR}/factorio-update"
  invocation="python ${UPDATE_SCRIPT} --for-version ${version} --package ${package} --output-path ${tmpdir}"
  if [ ${UPDATE_EXPERIMENTAL} -gt 0 ]; then
    invocation="${invocation} --experimental"
  fi
  
  if [ ${HEADLESS} -eq 0 ]; then
    #GoodGuy Wube Software allows you to download the headless for free - yay! but you still have to
    #buy the game if you want to download the sound/gfx client
    invocation="${invocation} --user ${UPDATE_USERNAME} --token ${UPDATE_TOKEN}"
  fi

  echo "Checking for updates..."
  result=`as_user "${invocation} --dry-run"`
  exitcode=$?
  if [ ${exitcode} -gt 0 ]; then
    echo "Update check failed!"
    exit 1
  else
    newversion=`echo ${result} |egrep '^Dry run: ' |egrep -o '[0-9\.]+' |tail -n 1`
  fi

  if [ -z "${newversion}" ]; then
    echo "No new updates for ${package} ${version}"
    exit 0
  else
    echo "New version ${package} ${newversion}"
  fi

  # Go or no Go?
  if [ ${dryrun} -gt 0 ]; then 
    echo "Dry run, not taking further actions!"
    # allow scripts to read return code 0 for no updates and 2 if there are updates to apply 
    if ! [ -z "${newversion}" ]; then
      exit 2
    fi
    exit 0
  fi

  if [ -e ${tmpdir} ]; then
    echo "Aborting update! Temporary directory already exists ${tmpdir}"
    echo "Remnants from a previously failed update?"
    exit 1
  fi

  if ! as_user "mkdir -p ${tmpdir}"; then
    echo "Aborting update! Unable to create tmpdir: ${tmpdir}"
    exit 1
  fi

  # Time to download the updates
  if ! as_user "${invocation}"; then
    echo "Aborting update!"
    rm -rf ${tmpdir}
    exit 1
  fi
  
  # Stop the server if it is running.
  if is_running; then
    stop_service
  fi

  for patch in $(find ${tmpdir} -type f -name "*.zip" | sort); do
    echo "Applying ${patch} ..."
    result=`as_user "$BINARY --apply-update ${patch}"`
    exitcode=$?
    if [ $exitcode -gt 0 ]; then
      echo "${result}"
      echo
      echo "Error! Failed to apply update"
      echo "You can try to apply it manually with:"
      echo "su ${USERNAME} -c \"${BINARY} --apply-update ${patch}\""
      exit 1
    fi
  done

  echo "Successfully updated factorio"
  rm -rf ${tmpdir}
}

case "$1" in
  start)
    # Starts the server
    if is_running; then
      echo "Server already running."
      exit 0
    else
       if ! start_service; then
         echo "Could not start $SERVICE_NAME"
         exit 1
       fi
    fi
    ;;

  stop)
    # Stops the server
    if is_running; then
      if ! stop_service; then
        echo "Could not stop $SERVICE_NAME"
        exit 1
      fi
    else
      echo "No running server."
      exit 0
    fi
    ;;

  restart)
    # Restarts the server
    if is_running; then
      if stop_service; then
        if ! start_service; then
          echo "Could not start $SERVICE_NAME after restart!"
          exit 1
        fi
      else
        echo "Failed to stop $SERVICE_NAME, aborting restart!"
        exit 1
      fi
    else
      echo "No running server to restart, starting it..."
      if ! start_service; then
        echo "Could not start $SERVICE_NAME"
        exit 1
      fi
    fi
    ;;

  status)
    # Shows server status
    if is_running; then
      echo "$SERVICE_NAME is running."
    else
      echo "$SERVICE_NAME is not running."
      exit 1
    fi
    ;;

  new-game)
    # Stop Service
    if is_running; then
      if ! stop_service; then
        echo "Failed to stop server, unable to create new save"
        exit 1
      fi
    fi

    if ! as_user "$BINARY --create ${WRITE_DIR}/saves/${SAVE_NAME}"; then
      echo "Failed to create new game"
      exit 1
    else
      echo "New game created"
    fi
    ;;
	
  save-game)
    savename="${WRITE_DIR}/saves/$2.zip"

    # Stop Service
    if is_running; then
      if ! stop_service; then
        echo "Failed to stop server, unable to save as \"$2\""
        exit 1
      fi
    fi

    if ! as_user "cp ${WRITE_DIR}/saves/${SAVE_NAME}.zip ${savename}"; then
      echo "Error! Failed to save game"
      exit 1
    fi
    ;;

  load-save)
    # Ensure we get a new save file name
    newsave=${WRITE_DIR}/saves/$2.zip
    if [ ! -f "${newsave}" ]; then
      echo "Save \"${newsave}\" does not exist, aborting action!"
      exit 1
    fi

    # Since stopping the server causes a save we have to stop the server to do this
    if is_running; then
      if ! stop_service; then
        echo "Aborting, unable to stop $SERVICE_NAME"
        exit 1
      fi
    fi

    # Touch the new save file
    as_user "touch ${newsave}"
    ;;
  install)
    install "$2"
    ;;
  update)
    update "$2"
    ;;
  help|--help|-h)
    usage
    ;;
  *)
    echo "No such command!"
    echo
    usage
    exit 1
    ;;
esac

exit 0
